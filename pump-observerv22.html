<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pump.fun Token Volume Observer (Enhanced with Strategies, No Moralis)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0;
            padding: 20px;
            background-color: #f0f4f8; 
            color: #2c3e50; 
            line-height: 1.6;
        }
        h1, h2 { 
            color: #1a202c; 
            font-weight: 700;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2rem;
            text-align: center;
            background: linear-gradient(135deg, #4CAF50, #2196F3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        table { 
            border-collapse: separate; 
            border-spacing: 0;
            width: 100%; 
            margin-top: 20px; 
            background-color: #ffffff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        th, td { 
            padding: 16px; 
            text-align: left; 
            border-bottom: 1px solid #e2e8f0;
        }
        th { 
            background-color: #3182ce; 
            color: white; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr:hover { 
            background-color: #edf2f7; 
            transition: background-color 0.3s ease;
        }
        .banger { 
            background-color: #c6f6d5; 
            font-weight: 600; 
        } /* Light green for potential bangers */
        img { 
            max-width: 50px; 
            height: auto; 
            border-radius: 8px;
        }
        .token-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            margin-bottom: 40px;
        }
        .token-card {
            position: relative;
            background-color: #ffffff;
            border: none;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s ease;
            will-change: box-shadow;
        }
        .token-card:hover {
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        }
        .token-card img {
            max-width: 80px;
            height: auto;
            border-radius: 50%;
            margin-bottom: 10px;
        }
        .token-card h3 {
            margin: 10px 0;
            font-size: 1.2rem;
            color: #2d3748;
        }
        .token-card p {
            margin: 8px 0;
            font-size: 0.9rem;
            color: #4a5568;
        }
        .remove-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #e53e3e;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
        }
        .remove-btn:hover {
            background-color: #c53030;
        }
        a {
            color: #3182ce;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        a:hover {
            color: #2c5282;
        }
        progress {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background-color: #e2e8f0;
        }
        progress::-webkit-progress-bar {
            background-color: #e2e8f0;
            border-radius: 4px;
        }
        progress::-webkit-progress-value {
            background-color: #48bb78;
            border-radius: 4px;
        }
        @media (max-width: 768px) {
            .token-list {
                grid-template-columns: repeat(auto-fit, minmax(100%, 1fr));
            }
        }
        #status {
            text-align: center;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .led-green {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: limegreen;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .led-red {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .metrics {
            background-color: #ffffff;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .metric {
            display: block;
            font-family: monospace;
            font-size: 1.1rem;
            margin: 5px 0;
            color: #2d3748;
        }
        .cto-banger {
            background-color: #e9d8fd;
            font-weight: bold;
            border: 2px solid #9f7aea;
        }
    </style>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
</head>
<body>
    <div id="status">
        <span id="status-text">WebSocket Disconnected</span> <span id="led" class="led-red"></span>
    </div>
    <div id="cto-monitor"></div>
    <div id="bonded-tokens"></div>
    <div id="tokens"></div>

    <script>
        let ws;
        let tokens = {}; // mint => { mint, marketCap, volume, lastVSol, creationTime, lastUpdateTime, deployer, bundleDetected, bonded, bondingVolume, postBondingVolume, hasExceededThreshold, name, symbol, description, logo, earlyTraders, devEverBought }
        let ctoWatch = {}; // mint => { ... , eventTime, eventType, minVSolPostEvent, minVSolTime, isCTO }
        let subscribedMints = new Set();
        let reconnectDelay = 1000; // Initial reconnect backoff in ms
        const BUNDLE_THRESHOLD_SOL = 1; // Large buy threshold
        const BUNDLE_TIME_MIN = 3; // Minutes for early detection
        const INITIAL_VIRTUAL_SOL = 30; // Initial virtual SOL in the bonding curve
        const BONDING_COMPLETE_VSOL = 115; // Virtual SOL threshold for bonding curve completion (initial 30 + accumulated 85)
        const BONDING_PROGRESS_THRESHOLD = 10; // Increased to catch more drops
        const SOL_MINT = 'So11111111111111111111111111111111111111112';
        const TOKEN_SUPPLY = 1000000000; // 1 billion tokens for Pump.fun
        let solPriceUsd = 0; // Updated periodically
        const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
        const PUMP_FUN_PROGRAM = new solanaWeb3.PublicKey('6EF8rrecthR5Dkzon8NQiDSV7mpC5uqxWDxRyZ35igKP');
        const INACTIVITY_TIMEOUT_MS = 5 * 60000; // Reduced to 5 minutes for quicker removal
        const MIN_VOLUME_THRESHOLD = 1; // Remove non-bonded tokens older than 5 min with volume < 1 SOL
        const MIN_AGE_FOR_LOW_VOLUME_REMOVAL = 5; // Minutes
        const MEDIUM_VOLUME_THRESHOLD = 35; // Remove non-bonded tokens older than 3 min with volume < 35 SOL
        const MIN_AGE_FOR_MEDIUM_VOLUME_REMOVAL = 3; // Minutes
        const CTO_RECOVERY_THRESHOLD = 5; // Lowered for easier detection
        const WATCH_EXPIRATION_MS = 24 * 60 * 60 * 1000; // 24 hours
        const CTO_MIN_AGE_FOR_WATCH_MIN = 0; // Removed the 5 min rule
        const CTO_SPIKE_AFTER_AGE_MIN = 5; // Min age at dip for CTO detection

        const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.com');

        function readU64(data, offset) {
            let value = BigInt(0);
            for (let i = 0; i < 8; i++) {
                value += BigInt(data[offset + i]) << BigInt(8 * i);
            }
            return value;
        }

        function readU32(data, offset) {
            return data[offset] |
                   (data[offset + 1] << 8) |
                   (data[offset + 2] << 16) |
                   (data[offset + 3] << 24);
        }

        function readString(data, offset) {
            const len = readU32(data, offset);
            const nextOffset = offset + 4 + len;
            const strBytes = data.slice(offset + 4, nextOffset);
            const str = new TextDecoder().decode(strBytes).replace(/\0/g, '').trim();
            return { str, nextOffset };
        }

        function parseMetadata(data) {
            let offset = 0;
            const key = data[offset];
            if (key !== 4) return null; // MetadataV1 key
            offset += 1;
            offset += 32; // update_authority
            offset += 32; // mint
            // DataV1
            const nameRes = readString(data, offset);
            const name = nameRes.str;
            offset = nameRes.nextOffset;
            const symbolRes = readString(data, offset);
            const symbol = symbolRes.str;
            offset = symbolRes.nextOffset;
            const uriRes = readString(data, offset);
            const uri = uriRes.str;
            return { name, symbol, uri };
        }

        async function fetchOnChainMetadata(mintStr) {
            try {
                const mint = new solanaWeb3.PublicKey(mintStr);
                const [metadataPDA] = solanaWeb3.PublicKey.findProgramAddressSync(
                    [Buffer.from('metadata'), METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()],
                    METADATA_PROGRAM_ID
                );
                const accountInfo = await connection.getAccountInfo(metadataPDA);
                if (!accountInfo || !accountInfo.data) return null;
                return parseMetadata(accountInfo.data);
            } catch (error) {
                console.error('Error fetching on-chain metadata for ' + mintStr + ':', error);
                return null;
            }
        }

        async function isBonded(mintStr) {
            try {
                const mint = new solanaWeb3.PublicKey(mintStr);
                const [bondingPda] = solanaWeb3.PublicKey.findProgramAddressSync(
                    [Buffer.from('bonding_curve'), mint.toBuffer()],
                    PUMP_FUN_PROGRAM
                );
                const acc = await connection.getAccountInfo(bondingPda);
                if (!acc || !acc.data || acc.data.length < 33) return true; // Assume bonded if no account or too small
                return acc.data[32] === 1; // complete flag at offset 32
            } catch (error) {
                console.error('Error checking if bonded for ' + mintStr + ':', error);
                return false;
            }
        }

        async function fetchDeployer(mintStr) {
            try {
                const mint = new solanaWeb3.PublicKey(mintStr);
                const signatures = await connection.getSignaturesForAddress(mint, {limit: 1});
                if (signatures.length === 0) return 'unknown';
                const tx = await connection.getTransaction(signatures[0].signature, {maxSupportedTransactionVersion: 0});
                if (!tx) return 'unknown';
                return tx.transaction.message.accountKeys[0].pubkey.toBase58();
            } catch (error) {
                console.error('Error fetching deployer for ' + mintStr + ':', error);
                return 'unknown';
            }
        }

        function connectWebSocket() {
            ws = new WebSocket('wss://pumpportal.fun/api/data');

            ws.onopen = () => {
                console.log('Connected');
                document.getElementById('status-text').textContent = 'WebSocket Connected';
                document.getElementById('led').className = 'led-green';
                ws.send(JSON.stringify({ method: 'subscribeNewToken' }));
                if (subscribedMints.size > 0) {
                    ws.send(JSON.stringify({ method: 'subscribeTokenTrade', keys: Array.from(subscribedMints) }));
                }
                reconnectDelay = 1000; // Reset backoff on successful connect
            };

            ws.onmessage = (event) => {
                const message = event.data;
                console.log('Received message:', message);

                if (typeof message === 'string' && !message.startsWith('{') && !message.startsWith('[')) {
                    console.log('Keepalive echoed:', message);
                    ws.send(message); // Echo back to keep connection alive
                    return;
                }

                try {
                    const data = JSON.parse(message);
                    const mint = data.mint;
                    if (!mint) {
                        console.warn('No mint in data:', data);
                        return;
                    }

                    const now = Date.now();
                    if (!tokens[mint] && !ctoWatch[mint]) {
                        // New token created
                        if (data.vSolInBondingCurve === undefined || data.marketCapSol === undefined) {
                            console.warn('Missing fields for new token:', data);
                            return;
                        }
                        tokens[mint] = {
                            mint,
                            marketCap: data.marketCapSol,
                            volume: data.vSolInBondingCurve, // Initial volume
                            lastVSol: data.vSolInBondingCurve,
                            creationTime: now,
                            lastUpdateTime: now,
                            deployer: data.traderPublicKey || 'unknown',
                            bundleDetected: false,
                            bonded: false,
                            bondingVolume: 0,
                            postBondingVolume: 0,
                            hasExceededThreshold: false,
                            name: data.name || 'Unknown',
                            symbol: data.symbol || 'N/A',
                            description: 'No description',
                            logo: '',
                            earlyTraders: new Set(),
                            devEverBought: false
                        };
                        subscribedMints.add(mint);
                        ws.send(JSON.stringify({ method: 'subscribeTokenTrade', keys: Array.from(subscribedMints) }));

                        if (tokens[mint].deployer === 'unknown') {
                            fetchDeployer(mint).then(d => {
                                if (d !== 'unknown') {
                                    tokens[mint].deployer = d;
                                }
                                render();
                            });
                        }

                        fetchOnChainMetadata(mint).then(meta => {
                            if (meta) {
                                if (tokens[mint].name === 'Unknown') tokens[mint].name = meta.name || 'Unknown';
                                if (tokens[mint].symbol === 'N/A') tokens[mint].symbol = meta.symbol || 'N/A';
                                if (meta.uri && !data.uri) {
                                    fetchMetadataFromUri(mint, meta.uri);
                                }
                            }
                            render();
                        });

                        if (data.uri) {
                            fetchMetadataFromUri(mint, data.uri);
                        }
                    } else {
                        let t;
                        if (tokens[mint]) {
                            t = tokens[mint];
                        } else if (ctoWatch[mint]) {
                            t = ctoWatch[mint];
                        } else {
                            return;
                        }

                        let delta = 0;
                        if (data.vSolInBondingCurve !== undefined) {
                            delta = data.vSolInBondingCurve - t.lastVSol;
                            if (delta !== 0) {
                                t.volume += Math.abs(delta);
                                t.lastUpdateTime = now;
                            }
                            t.lastVSol = data.vSolInBondingCurve;
                        }
                        if (data.marketCapSol !== undefined) {
                            t.marketCap = data.marketCapSol;
                        }

                        if (!t.bonded && data.vSolInBondingCurve >= BONDING_COMPLETE_VSOL) {
                            t.bonded = true;
                            t.bondingVolume = t.volume;
                            t.postBondingVolume = 0;
                            ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                            subscribedMints.delete(mint);
                            if (ctoWatch[mint]) {
                                tokens[mint] = t;
                                delete ctoWatch[mint];
                            }
                        }

                        if (tokens[mint]) {
                            if (data.txType === 'sell' && data.traderPublicKey === t.deployer) {
                                const ageMin = (now - t.creationTime) / 60000;
                                if (ageMin > CTO_MIN_AGE_FOR_WATCH_MIN) {
                                    console.log('Dev sell detected, moving to CTO watch:', mint);
                                    ctoWatch[mint] = { ...t, eventTime: now, eventType: t.bundleDetected ? 'bundle_dev_sell' : 'dev_sell', minVSolPostEvent: t.lastVSol, minVSolTime: now, isCTO: false };
                                    delete tokens[mint];
                                } else {
                                    console.log('Dev sell detected but too young, removing token:', mint);
                                    delete tokens[mint];
                                    subscribedMints.delete(mint);
                                    ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                                }
                                render();
                                return;
                            }

                            if (!t.bonded) {
                                const vsol = t.lastVSol;
                                let currentProgress = 0;
                                if (vsol > INITIAL_VIRTUAL_SOL) {
                                    currentProgress = ((1 - INITIAL_VIRTUAL_SOL / vsol) / (1 - INITIAL_VIRTUAL_SOL / BONDING_COMPLETE_VSOL) * 100);
                                }
                                if (currentProgress > BONDING_PROGRESS_THRESHOLD && !t.hasExceededThreshold) {
                                    t.hasExceededThreshold = true;
                                }
                                if (t.hasExceededThreshold && currentProgress < BONDING_PROGRESS_THRESHOLD) {
                                    const ageMin = (now - t.creationTime) / 60000;
                                    if (ageMin > CTO_MIN_AGE_FOR_WATCH_MIN) {
                                        console.log('Token dropped below progress threshold, moving to CTO watch:', mint);
                                        ctoWatch[mint] = { ...t, eventTime: now, eventType: t.bundleDetected ? 'bundle_drop' : 'progress_drop', minVSolPostEvent: t.lastVSol, minVSolTime: now, isCTO: false };
                                        delete tokens[mint];
                                    } else {
                                        console.log('Token dropped below progress threshold but too young, removing:', mint);
                                        delete tokens[mint];
                                        subscribedMints.delete(mint);
                                        ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                                    }
                                    render();
                                    return;
                                }
                            }

                            if (data.txType === 'buy' && data.traderPublicKey === t.deployer) {
                                t.devEverBought = true;
                            }

                            if (data.txType === 'buy' && (now - t.creationTime) / 60000 < BUNDLE_TIME_MIN) {
                                t.earlyTraders.add(data.traderPublicKey);
                                if (t.earlyTraders.size > 1) {
                                    console.log('Multiple early traders detected (potential bundle/snipe):', mint);
                                    t.bundleDetected = true;
                                }
                                if (data.solAmount > BUNDLE_THRESHOLD_SOL) {
                                    console.log('Large early buy detected (potential bundle/snipe):', mint);
                                    t.bundleDetected = true;
                                }
                            }
                        } else if (ctoWatch[mint]) {
                            if (delta < 0) {
                                if (t.lastVSol < t.minVSolPostEvent) {
                                    t.minVSolPostEvent = t.lastVSol;
                                    t.minVSolTime = now;
                                }
                            }
                            const recovery = t.lastVSol - t.minVSolPostEvent;
                            const minAgeAtDip = (t.minVSolTime - t.creationTime) / 60000;
                            if (!t.isCTO && recovery > CTO_RECOVERY_THRESHOLD && minAgeAtDip > CTO_SPIKE_AFTER_AGE_MIN) {
                                t.isCTO = true;
                                console.log('CTO detected for ' + mint + ' with recovery ' + recovery.toFixed(2) + ' SOL after dip');
                            }
                        }
                    }

                    render();
                } catch (error) {
                    console.error('Message processing error:', error, message);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('WebSocket closed; reconnecting in ' + reconnectDelay + 'ms...');
                document.getElementById('status-text').textContent = 'WebSocket Disconnected';
                document.getElementById('led').className = 'led-red';
                setTimeout(connectWebSocket, reconnectDelay);
                reconnectDelay = Math.min(reconnectDelay * 2, 30000); // Exponential backoff, max 30s
            };
        }

        async function fetchMetadataFromUri(mint, uri) {
            try {
                const response = await fetch(uri);
                if (!response.ok) {
                    throw new Error('Metadata fetch failed');
                }
                const meta = await response.json();
                let store = tokens[mint] || ctoWatch[mint];
                if (store) {
                    store.description = meta.description || 'No description';
                    store.logo = meta.image || '';
                    render();
                }
            } catch (error) {
                console.error('Error fetching metadata from URI for ' + mint + ':', error);
                let store = tokens[mint] || ctoWatch[mint];
                if (store) {
                    store.description = 'Failed to fetch';
                    store.logo = '';
                    render();
                }
            }
        }

        function cleanupInactiveTokens() {
            const now = Date.now();
            const inactiveMints = [];
            for (let mint in tokens) {
                const t = tokens[mint];
                const ageMin = (now - t.creationTime) / 60000;
                if (now - t.lastUpdateTime > INACTIVITY_TIMEOUT_MS) { // Inactive
                    inactiveMints.push(mint);
                } else if (!t.bonded && ageMin > MIN_AGE_FOR_LOW_VOLUME_REMOVAL && t.volume < MIN_VOLUME_THRESHOLD) { // Low volume old tokens
                    console.log('Removing low volume non-bonded token:', mint);
                    inactiveMints.push(mint);
                } else if (!t.bonded && ageMin > MIN_AGE_FOR_MEDIUM_VOLUME_REMOVAL && t.volume < MEDIUM_VOLUME_THRESHOLD) { // Medium low volume after 3 min
                    console.log('Removing medium low volume non-bonded token:', mint);
                    inactiveMints.push(mint);
                }
            }
            inactiveMints.forEach(mint => {
                delete tokens[mint];
                subscribedMints.delete(mint);
            });

            const expiredCtoMints = [];
            for (let mint in ctoWatch) {
                const t = ctoWatch[mint];
                if (now - t.creationTime > WATCH_EXPIRATION_MS) {
                    console.log('Expiring CTO watch token:', mint);
                    expiredCtoMints.push(mint);
                }
            }
            expiredCtoMints.forEach(mint => {
                delete ctoWatch[mint];
                subscribedMints.delete(mint);
            });

            if ((inactiveMints.length > 0 || expiredCtoMints.length > 0) && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ method: 'subscribeTokenTrade', keys: Array.from(subscribedMints) }));
            }
            render();
        }

        async function updateSolPrice() {
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${SOL_MINT}`);
                const data = await response.json();
                if (data.pairs && data.pairs.length > 0) {
                    solPriceUsd = parseFloat(data.pairs[0].priceUsd);
                }
            } catch (error) {
                console.error('Error fetching SOL price:', error);
            }
        }

        async function updateBondedTokens() {
            if (solPriceUsd === 0) return;
            const now = Date.now();
            for (let mint in tokens) {
                const t = tokens[mint];
                if (t.bonded) {
                    try {
                        const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`);
                        const data = await response.json();
                        if (data.pairs && data.pairs.length > 0) {
                            let pair = data.pairs.find(p => p.dexId === 'raydium');
                            if (!pair) pair = data.pairs[0];
                            const newPostVolUsd = pair.volume?.h24 || 0;
                            const newPostVolSol = newPostVolUsd / solPriceUsd;
                            if (newPostVolSol > t.postBondingVolume) {
                                t.postBondingVolume = newPostVolSol;
                                t.volume = t.bondingVolume + newPostVolSol;
                            }
                            t.lastUpdateTime = now;
                            if (pair.priceNative && pair.quoteToken?.symbol === 'SOL') {
                                t.marketCap = parseFloat(pair.priceNative) * TOKEN_SUPPLY;
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching DexScreener for ' + mint + ':', error);
                    }
                }
            }
            render();
        }

        async function checkBondingStatus() {
            for (let mint in tokens) {
                const t = tokens[mint];
                if (!t.bonded) {
                    const bonded = await isBonded(mint);
                    if (bonded) {
                        console.log('Detected bonding via RPC for:', mint);
                        t.bonded = true;
                        t.bondingVolume = t.volume;
                        t.postBondingVolume = 0;
                        if (subscribedMints.has(mint)) {
                            ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                            subscribedMints.delete(mint);
                        }
                        render();
                    }
                }
            }
            for (let mint in ctoWatch) {
                const t = ctoWatch[mint];
                if (!t.bonded) {
                    const bonded = await isBonded(mint);
                    if (bonded) {
                        console.log('Detected bonding via RPC for CTO watch:', mint);
                        t.bonded = true;
                        t.bondingVolume = t.volume;
                        t.postBondingVolume = 0;
                        if (subscribedMints.has(mint)) {
                            ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                            subscribedMints.delete(mint);
                        }
                        tokens[mint] = t;
                        delete ctoWatch[mint];
                        render();
                    }
                }
            }
        }

        async function checkDevBalances() {
            const now = Date.now();
            for (let mint in tokens) {
                const t = tokens[mint];
                if (!t.bonded && t.deployer !== 'unknown') {
                    try {
                        const deployerPk = new solanaWeb3.PublicKey(t.deployer);
                        const mintPk = new solanaWeb3.PublicKey(mint);
                        const ata = splToken.getAssociatedTokenAddressSync(mintPk, deployerPk);
                        const balanceInfo = await connection.getTokenAccountBalance(ata);
                        const balance = parseInt(balanceInfo.value.amount);
                        if (t.devEverBought && balance === 0) {
                            const ageMin = (now - t.creationTime) / 60000;
                            if (ageMin > CTO_MIN_AGE_FOR_WATCH_MIN) {
                                console.log('Dev rug detected (balance 0), moving to CTO watch:', mint);
                                ctoWatch[mint] = { ...t, eventTime: now, eventType: t.bundleDetected ? 'bundle_dev_rug' : 'dev_rug', minVSolPostEvent: t.lastVSol, minVSolTime: now, isCTO: false };
                                delete tokens[mint];
                            } else {
                                console.log('Dev rug (balance 0) but too young, removing:', mint);
                                delete tokens[mint];
                                subscribedMints.delete(mint);
                                if (ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                                }
                            }
                            render();
                        }
                    } catch (error) {
                        if (t.devEverBought) {
                            const ageMin = (now - t.creationTime) / 60000;
                            if (ageMin > CTO_MIN_AGE_FOR_WATCH_MIN) {
                                console.log('Dev rug detected (ATA not found), moving to CTO watch:', mint);
                                ctoWatch[mint] = { ...t, eventTime: now, eventType: t.bundleDetected ? 'bundle_dev_rug' : 'dev_rug', minVSolPostEvent: t.lastVSol, minVSolTime: now, isCTO: false };
                                delete tokens[mint];
                            } else {
                                console.log('Dev rug (ATA not found) but too young, removing:', mint);
                                delete tokens[mint];
                                subscribedMints.delete(mint);
                                if (ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                                }
                            }
                            render();
                        }
                    }
                }
            }
        }

        function removeToken(mint) {
            if (tokens[mint]) {
                delete tokens[mint];
            } else if (ctoWatch[mint]) {
                delete ctoWatch[mint];
            }
            if (subscribedMints.has(mint)) {
                subscribedMints.delete(mint);
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ method: 'unsubscribeTokenTrade', keys: [mint] }));
                }
            }
            render();
        }

        function render() {
            const now = Date.now();

            // Render CTO Monitor
            const watchedCount = Object.keys(ctoWatch).length;
            const ctoCount = Object.values(ctoWatch).filter(t => t.isCTO).length;
            let ctoHtml = `
                <div class="metrics">
                    <span class="metric">cto_watched_tokens ${watchedCount}</span>
                    <span class="metric">cto_detected ${ctoCount}</span>
                </div>
                <div class="token-list">`;
            const ctoTokens = Object.values(ctoWatch).filter(t => t.isCTO).sort((a, b) => (b.lastVSol - b.minVSolPostEvent) - (a.lastVSol - a.minVSolPostEvent));
            ctoTokens.forEach(t => {
                const ageMin = ((now - t.creationTime) / 60000).toFixed(1);
                const logoImg = t.logo ? `<img src="${t.logo}" alt="Logo">` : '';
                const name = t.name || 'Unknown';
                const symbol = t.symbol || 'N/A';
                const desc = t.description || 'No description';
                const mintLink = `<a href="https://www.pump.fun/${t.mint}" target="_blank">pump.fun</a>`;
                const xLink = `<a href="https://x.com/search?q=${t.mint}" target="_blank">X</a>`;
                const vsol = t.lastVSol || 0;
                let progressPercent = 0;
                if (vsol > INITIAL_VIRTUAL_SOL) {
                    progressPercent = ((1 - INITIAL_VIRTUAL_SOL / vsol) / (1 - INITIAL_VIRTUAL_SOL / BONDING_COMPLETE_VSOL) * 100).toFixed(1);
                }
                const progressBar = `<progress value="${progressPercent}" max="100"></progress> ${progressPercent}%`;
                const recovery = (t.lastVSol - t.minVSolPostEvent).toFixed(2);
                const rowClass = t.isCTO ? 'cto-banger' : '';
                ctoHtml += `
                    <div class="token-card ${rowClass}">
                        <button class="remove-btn" onclick="removeToken('${t.mint}')">×</button>
                        ${logoImg}
                        <h3>${name} (${symbol}) ${xLink}</h3>
                        <p>${desc}</p>
                        <p>Mint: ${mintLink}</p>
                        <p>Volume: ${(t.volume || 0).toFixed(2)} SOL</p>
                        <p>Market Cap: ${(t.marketCap || 0).toFixed(2)} SOL</p>
                        <p>Age: ${ageMin} min</p>
                        <p>Status: CTO Watch - Bonding Progress: ${progressBar}</p>
                        <p>Event Type: ${t.eventType}</p>
                        <p>Recovery: ${recovery} SOL</p>
                    </div>`;
            });
            ctoHtml += '</div>';
            document.getElementById('cto-monitor').innerHTML = ctoHtml;

            // Render Bonded Tokens
            const bondedTokens = Object.values(tokens)
                .filter(t => t.bonded)
                .sort((a, b) => (b.volume || 0) - (a.volume || 0));
            let bondedHtml = '<div class="token-list">';
            bondedTokens.forEach(t => {
                const ageMin = ((now - t.creationTime) / 60000).toFixed(1);
                const logoImg = t.logo ? `<img src="${t.logo}" alt="Logo">` : '';
                const name = t.name || 'Unknown';
                const symbol = t.symbol || 'N/A';
                const desc = t.description || 'No description';
                const mintLink = `<a href="https://www.pump.fun/${t.mint}" target="_blank">pump.fun</a>`;
                const xLink = `<a href="https://x.com/search?q=${t.mint}" target="_blank">X</a>`;
                const dexLink = `<a href="https://dexscreener.com/solana/${t.mint}" target="_blank">DexScreener</a>`;
                const rowClass = t.isCTO ? 'cto-banger' : '';
                const ctoTag = t.isCTO ? '<p style="color: purple;">CTO Detected</p>' : '';
                bondedHtml += `
                    <div class="token-card ${rowClass}">
                        <button class="remove-btn" onclick="removeToken('${t.mint}')">×</button>
                        ${logoImg}
                        <h3>${name} (${symbol}) ${xLink}</h3>
                        <p>${desc}</p>
                        <p>Mint: ${mintLink} | ${dexLink}</p>
                        <p>Volume: ${(t.volume || 0).toFixed(2)} SOL</p>
                        <p>Market Cap: ${(t.marketCap || 0).toFixed(2)} SOL</p>
                        <p>Age: ${ageMin} min</p>
                        <p>Status: Bonded</p>
                        ${ctoTag}
                    </div>`;
            });
            bondedHtml += '</div>';
            document.getElementById('bonded-tokens').innerHTML = bondedHtml;

            // Render Ongoing Tokens
            const ongoingTokens = Object.values(tokens)
                .filter(t => !t.bonded)
                .sort((a, b) => {
                    const aAge = (now - a.creationTime) / 60000;
                    const bAge = (now - b.creationTime) / 60000;
                    const isABanger = (aAge > 3 && a.volume > 10) ? 1 : 0;
                    const isBBanger = (bAge > 3 && b.volume > 10) ? 1 : 0;
                    if (isABanger !== isBBanger) {
                        return isBBanger - isABanger; // Bangers first
                    }
                    return (b.volume || 0) - (a.volume || 0);
                });
            let ongoingHtml = '<div class="token-list">';
            ongoingTokens.forEach(t => {
                const ageMin = ((now - t.creationTime) / 60000).toFixed(1);
                const isBanger = (ageMin > 3 && t.volume > 10);
                let rowClass = isBanger ? 'banger ' : '';
                const logoImg = t.logo ? `<img src="${t.logo}" alt="Logo">` : '';
                const name = t.name || 'Unknown';
                const symbol = t.symbol || 'N/A';
                const desc = t.description || 'No description';
                const mintLink = `<a href="https://www.pump.fun/${t.mint}" target="_blank">pump.fun</a>`;
                const xLink = `<a href="https://x.com/search?q=${t.mint}" target="_blank">X</a>`;
                const vsol = t.lastVSol || 0;
                let progressPercent = 0;
                if (vsol > INITIAL_VIRTUAL_SOL) {
                    progressPercent = ((1 - INITIAL_VIRTUAL_SOL / vsol) / (1 - INITIAL_VIRTUAL_SOL / BONDING_COMPLETE_VSOL) * 100).toFixed(1);
                }
                const progressBar = `<progress value="${progressPercent}" max="100"></progress> ${progressPercent}%`;
                const bundleWarning = t.bundleDetected ? '<p style="color: red;">Potential Snipe/Bundle Detected</p>' : '';
                ongoingHtml += `
                    <div class="token-card ${rowClass}">
                        <button class="remove-btn" onclick="removeToken('${t.mint}')">×</button>
                        ${logoImg}
                        <h3>${name} (${symbol}) ${xLink}</h3>
                        <p>${desc}</p>
                        <p>Mint: ${mintLink}</p>
                        <p>Volume: ${(t.volume || 0).toFixed(2)} SOL</p>
                        <p>Market Cap: ${(t.marketCap || 0).toFixed(2)} SOL</p>
                        <p>Age: ${ageMin} min</p>
                        <p>Status: Ongoing - Bonding Progress: ${progressBar}</p>
                        ${bundleWarning}
                    </div>`;
            });
            ongoingHtml += '</div>';
            document.getElementById('tokens').innerHTML = ongoingHtml;
        }

        connectWebSocket();
        setInterval(cleanupInactiveTokens, 30000);
        updateSolPrice();
        setInterval(updateSolPrice, 60000);
        setInterval(updateBondedTokens, 30000);
        setInterval(checkBondingStatus, 10000);
        setInterval(checkDevBalances, 30000);
    </script>
</body>
</html>